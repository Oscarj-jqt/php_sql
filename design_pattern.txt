Toute ce concept d'archirecture visant Ã  amÃ©liorer la maintenabilitÃ©, rÃ©utilisabilitÃ©, coÃ»ts est notamment dÃ»e au travail de C. Alexander et son livre 
"The Timeless way of building" qui renvoit donc Ã  "La maniÃ¨re intemporelle de construire"

Il introduit la notion "Design Pattern" dÃ©crit Ã  la couverture par "Objets orientÃ©s ,Ã©lÃ©ments rÃ©uilisables" dÃ©finis par :

"Each pattern describes a problem which occurs over and over again
in our environment, and then describes the core of the solution to
that problem, in such a way that you can use this solution a million
times over, without ever doing it the same way twice"

PopularisÃ© avec le GoF (1995)

SynthÃ¨se :

SynthÃ¨se : Design Patterns (Patrons de conception)
ğŸ—ï¸ Origine et dÃ©finition

Concept inspirÃ© de lâ€™architecture (Christopher Alexander, The Timeless Way of Building, 1979).

DÃ©mocratisÃ© en 1995 par le Gang of Four (GoF).

Un design pattern dÃ©crit un problÃ¨me rÃ©current de conception et une solution gÃ©nÃ©rique rÃ©utilisable.

Ce nâ€™est pas un algorithme, mais une architecture adaptable qui respecte les bonnes pratiques de POO.

Objectif : rÃ©utilisabilitÃ©, maintenabilitÃ©, rÃ©duction des coÃ»ts et cohÃ©rence du code.


Exemples de patterns courants
ğŸ§  Strategy

ProblÃ¨me : Modifier dynamiquement un comportement ou un algorithme.

Solution : DÃ©lÃ©guer la partie variable Ã  une classe via une interface commune.

Exemple : Choisir dynamiquement un mode de paiement ou un calcul de frais.

ğŸ‘‰ CatÃ©gorie : Behavioral.

ğŸ”’ Singleton

ProblÃ¨me : Garantir une instance unique dâ€™une classe.

Solution : Constructeur privÃ© + mÃ©thode statique getInstance().

Exemple : Connexion base de donnÃ©es.

ğŸ‘‰ CatÃ©gorie : Creational.

Instance globale :
Câ€™est un objet accessible partout dans le programme. Il nâ€™existe quâ€™un seul exemplaire de cette classe, utilisÃ© par tous.

Constructeur privÃ© :
Le constructeur sert Ã  crÃ©er un objet. Sâ€™il est privÃ©, personne ne peut crÃ©er un nouvel objet directement avec new.

MÃ©thode statique retournant lâ€™instance unique :
On crÃ©e une mÃ©thode spÃ©ciale (statique) qui vÃ©rifie si lâ€™objet existe dÃ©jÃ . Si non, elle le crÃ©e. Sinon, elle retourne lâ€™objet dÃ©jÃ  crÃ©Ã©.
Ainsi, on a toujours le mÃªme objet partout

ğŸ­ Factory

ProblÃ¨me : CrÃ©er des objets sans dÃ©pendre de leurs classes concrÃ¨tes.

Solution : DÃ©lÃ©guer la crÃ©ation Ã  une classe Factory.

But : RÃ©duire le couplage fort.

Exemple : DatabaseFactory::create("mysql").

ğŸ‘‰ CatÃ©gorie : Creational.


ğŸ¨ Decorator

ProblÃ¨me : Ajouter dynamiquement de nouvelles fonctionnalitÃ©s sans modifier le code dâ€™origine.

Solution : Encapsuler un objet dans dâ€™autres objets dÃ©corateurs.

Principe : Respecte le principe SOLID (Open/Closed).

Exemple : Ajouter des options Ã  un produit (ex : cafÃ© + lait + sucre).

ğŸ‘‰ CatÃ©gorie : Structural.



ğŸ§­ MVC (Model-View-Controller)

ProblÃ¨me : SÃ©parer la logique, lâ€™affichage et les interactions utilisateur.

Solution :

Model : DonnÃ©es et logique mÃ©tier

View : Interface et affichage

Controller : GÃ¨re les actions utilisateur

Exemples : Laravel, Symfony, frameworks PHP.

ğŸ‘‰ Pattern dâ€™architecture complet